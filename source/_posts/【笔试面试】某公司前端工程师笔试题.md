---
title: 某公司前端工程师笔试题
tags:
  - 笔试面试
abbrlink: 51a5d3ae
date: 2021-04-10 17:12:10
---



## 1、了解 Promise 吗？Promise 解决的痛点是什么？Promise解决的痛点还有其他方法可以解决吗？

参考文章：https://blog.csdn.net/weixin_43964148/article/details/105879357

- **了解 Promise 吗？**

  - Promise是一种异步编程的解决方案。

  - 根据PromiseA+定义，Promise有三种状态，分别是：`pending`（进行中） `fulfilled`(操作成功) `rejected`（操作失败）。

  - promise的状态只能由`pending`变成`fulfiied`和`rejected`，改变后就不再发生变化。如果改变已经发生了，你再对 Promise 对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。

  - 优点：有了 Promise 对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise 对象提供统一的接口，使得控制异步操作更加容易。

  - 缺点：首先，无法取消 Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部。第三，当处于 Pending 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。

  - 使用：

    ```javascript
    var promise = new Promise(function(resolve, reject){
        //当异步代码执行成功时，我们才会调用resolve(...), 当异步代码失败时就会调用reject(...)
        //在本例中，我们使用setTimeout(...)来模拟异步代码，实际编码时可能是XHR请求或是HTML5的一些API方法.
        setTimeout(function(){
            resolve("成功!"); //代码正常执行！
        }, 250);
    });
     
    promise.then(function(successMessage){
        //successMessage的值是上面调用resolve(...)方法传入的值.
        //successMessage参数不一定非要是字符串类型，这里只是举个例子
        document.write("Yay! " + successMessage);
    }, function(errorMessage){
        //errorMessage的值是reject(...)方法传入的值.
        //errorMessage参数不一定非要是字符串类型，这里只是举个例子
        document.write("No! " + errorMessage);
    });
    
    // function(errorMessage){} 函数也可以写成catch
    promise.then(function(successMessage){
        //successMessage的值是上面调用resolve(...)方法传入的值.
        //successMessage参数不一定非要是字符串类型，这里只是举个例子
        document.write("Yay! " + successMessage);
    }).catch(function(errorMessage){
        //errorMessage的值是reject(...)方法传入的值.
        //errorMessage参数不一定非要是字符串类型，这里只是举个例子
        document.write("No! " + errorMessage);
    });
    
    // Promise.all 和 Promise.race
    // p1,p2,p3是promise实例，这里不一定要写成数组，也可以写成其他具有 iterator 接口的数据格式，如对象。
    // promise.all 所有请求成功才进入resolve，一个失败就reject
    var p = Promise.all([p1,p2,p3]);
    // promise.race 所有请求成功才进入resolve，一个失败就reject
    var p = Promise.race([p1,p2,p3]);
    
    // Promise.resolve和Promise.reject
    // 有时需要将现有对象转为Promise对象，Promise.resolve方法就起到这个作用。
    // 下面代码将 jQuery 生成 deferred 对象，转为一个新的 ES6 的 Promise 对象。
    var jsPromise = Promise.resolve($.ajax('/whatever.json'));
    ```

- **Promise 解决的痛点是什么？**

  - **解决了异步操作回调嵌套的问题（又称为回调地狱）。**

    对于异步操作，如果存在一个操作的输出是另外一个操作的输入，就需要回调嵌套，如此一来，代码臃肿，可读性差，难以维护。

  - **回调调用时机不可控。**

    当使用setTimeout等异步的方式去做异步操作时，回调时机不可控，有可能早了或者晚了。

  - **回调不调用。**

    回调要被调用，Promise 就一定要决议，那么如果 Promise 永远没有决议呢？

    即使这样，Promise 也提供了解决方案，一种称为竞态的机制：

    ```javascript
    function timeoutPromise(delay) {  
    	return new Promise((resolve, reject) => {
            setTimeout(() => {
              reject("Timeout!");
            }, delay);
    	});
    }
    
    Promise.race([fun(), timeoutPromise(60 * 1000)]).then(() => {
        // fun()及时完成
      },  (err) => {
        // fun()被拒绝，或者超时
        // 通过err来查看是哪种情况
      }
    );
    ```

    通过以上模式，我们就可以保证fun()的调用，永远会有一个输出信号，防止永久挂起。

  - **调用次数过少或过多。**

    回调被调用的正确次数应该是 1，调用次数过少就就是未调用，上面已经解释过其解决方案；调用次数过多也很好处理：

    Promise 只能被决议一次，即使你试图多次调用 resolve 或者 reject，Promise 也只会接收第一次决议结果，而忽略后续所有调用。Promise 决议完成后，就会把 then 中注册人的回调加入事件队列等待执行，所以，then 中注册的回调也只会被调用一次。

  - **吞掉可能出现的错误或者异常。**

    当调用 Promise 时，如果你直接调用了 reject，那么这个 Promise 就会直接拒绝。其实不只是调用 reject，如果你在代码执行中，某个时间点上出现了一个 JavaScript 错误，比如 TypeError 或者 ReferenceError，那么这个错误也会被捕捉，并且会使这个 Promise 直接拒绝。

    这一点很重要，其有效地防止了一个方法出错时可能引起同步响应，而成功时却是异步响应的差异化结果。

    > 上面的第一点外的问题又被称为“信任问题”。

- **Promise解决的痛点还有其他方法可以解决吗？**

  Promise 解决的痛点还有其他方法可以解决，比如setTimeout、事件监听、回调函数、Generator函数，async/await

  - setTimeout：缺点不精确，只是确保在一定时间后加入到任务队列，并不保证立马执行。只有执行引擎栈中的代码执行完毕，主线程才会去读取任务队列

  - 事件监听：任务的执行不取决于代码的顺序，而取决于某个事件是否发生

  - [Generator函数](https://www.liaoxuefeng.com/wiki/1022910821149312/1023024381818112)

  - async/await

- **老旧浏览器没有Promise全局对象增么办?**

  引入es6-promise-polyfill

- **怎么让一个函数无论promise对象成功和失败都能被调用？**

  > PS: 主流浏览器都支持 `Promise.catch()`和 `Promise.finally()`

  可以扩展一个 `Promise.finally()`方法。

  ```javascript
  Promise.prototype.finally = function (callback) {
     var p=this.constructor;
     return this.then(
         //只要是promise对象就可以调用then方法
         value => p.resolve(callback()).then(() => value),
         reason => p.resolve(callback()).then(() => {throw reason})
     );
  }
  ```

- **红灯3秒亮一次，绿灯1秒亮一次，黄灯2秒亮一次；如何让三个灯不断交替重复亮灯？（用Promise实现）**

  ```javascript
  function red() {
      console.log('red');
  }
  function green() {
      console.log('green');
  }
  function yellow() {
      console.log('yellow');
  }
  
  var light = function (timmer, cb) {
      return new Promise(function (resolve, reject) {
          setTimeout(function () {
              cb();
              resolve();
          }, timmer);
      });
  };
  
  var step = function () {
      Promise.resolve().then(function () {
          return light(3000, red);
      }).then(function () {
          return light(2000, green);
      }).then(function () {
          return light(1000, yellow);
      }).then(function () {
          step();
      });
  }
  
  step();
  ```

- **实现 mergePromise 函数，把传进去的数组按顺序先后执行，并且把返回的数据先后放到数组 data 中。**

  ```javascript
  const timeout = ms => new Promise((resolve, reject) => {
      setTimeout(() => {
          resolve();
      }, ms);
  });
  
  const ajax1 = () => timeout(2000).then(() => {
      console.log('1');
      return 1;
  });
  
  const ajax2 = () => timeout(1000).then(() => {
      console.log('2');
      return 2;
  });
  
  const ajax3 = () => timeout(2000).then(() => {
      console.log('3');
      return 3;
  });
  
  const mergePromise = ajaxArray => {
      // 在这里实现你的代码
  	
  };
  
  mergePromise([ajax1, ajax2, ajax3]).then(data => {
      console.log('done');
      console.log(data); // data 为 [1, 2, 3]
  });
  
  // 要求分别输出
  // 1
  // 2
  // 3
  // done
  // [1, 2, 3]
  ```

  代码实现见此：

  ```javascript
  const mergePromise = ajaxArray => {
      // 保存数组中的函数执行后的结果
      var data = [];
  
      // Promise.resolve方法调用时不带参数，直接返回一个resolved状态的 Promise 对象。
      var sequence = Promise.resolve();
  
      ajaxArray.forEach(function (item) {
          // 第一次的 then 方法用来执行数组中的每个函数，
          // 第二次的 then 方法接受数组中的函数执行后返回的结果，
          // 并把结果添加到 data 中，然后把 data 返回。
          // 这里对 sequence 的重新赋值，其实是相当于延长了 Promise 链
          sequence = sequence.then(item).then(function (res) {
              data.push(res);
              return data;
          });
      })
  
      // 遍历结束后，返回一个 Promise，也就是 sequence， 他的 [[PromiseValue]] 值就是 data，
      // 而 data（保存数组中的函数执行后的结果） 也会作为参数，传入下次调用的 then 方法中。
      return sequence;
  };
  ```

- **手写Promise**

  见：https://mp.weixin.qq.com/s/C-U93BmK0U_iw3sqG0g70g



## 2、var、let、const的区别？

- 使用var声明的变量，其作用域为该语句所在的函数内（局部变量），且存在变量提升现象；

- let和const都是块级作用域，必须先声明，后使用。
- 使用const声明的是常量，简单类型数据不可以修改，复合类型的数据**内**的数据可以修改（不变的是引用）。
- const声明的时候必须赋值。



## 3、请用js去除字符串全部空格、头尾空格

```javascript
// 去除所有空格
function trimAll(str){
   return str.replace(/\s+/g, '');
}

// 去除头尾空格
function trim(str){
    // 方法1：String对象trim方法
    return str.trim()
    // 方法2：正则替换(如果这里延伸要把每一行的首尾空格都删除掉,)
    return str.replace(/^\s+|\s+$/g,'');
}

// 多行字符每一行的首尾空格删除(m：多行匹配 g：全局匹配)
function trimMore(str){
    return str.replace(/^\s+|\s+$/mg,'');
}
```



## 4、如何理解闭包？请用js写出一个闭包

> 参考：[深入浅出图解作用域链和闭包](http://muyiy.cn/blog/2/2.1.html#%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE)

闭包是指有权访问另外一个函数作用域中的局部变量的函数。简而言之，声明在一个函数中的函数，叫做闭包函数。

- 闭包的特点：
  - 让外部访问函数内部变量成为可能

  - 局部变量会常驻在内存中
  - 可以避免使用全局变量，防止全局变量污染
  - 会造成内存泄漏（有一块内存空间被长期占用，而不被释放）



## 5、http状态代码及其含义

- 1xx:   指示信息-表示请求已接收，继续处理

- 2xx：成功-表示请求已被成功接收

- 3xx：重定向-要完成请求必须进行更进一步的操作

- 4xx：客户端错误-请求有语法错误或请求无法实现

- 5xx：服务器错误-服务器未能实现合法的请求

  

**常见的状态码：**

`200 OK`：客户端请求成功
`206 Partial Content`：客户发送了一个带有Range头的GET请求，服务器完成了它
`301 Moved Permanently`：所请求的页面已经转移至新的URL
`302 Moved Temporarily`：所请求的页面已经临时转移至新的URL
`304 Not Modified`：客户端有缓冲的文档并发出了一个条件性的请求，服务器告诉客户，原来缓冲的文档还可以继续使用
`400 Bad Request`：客户端请求有语法错误，不能被服务器所理解
`401 Unauthorized`：请求未经制空权，这个 状态代码必须和WWW-Authenticate报头域一起使用
`403 Forbidden`：对被请求的页面被禁止
`404 Not Found`: 请求资源不存在
`500 Internal Server Error`：服务器发生不可预期的错误原来缓冲的文档还可以继续使用
`503 Server Unavailable`：请求未完成，服务器临时过载或当机，一段时间可能恢复正常



## 6、undefined和null有什么区别？





## 7、请写出Js有哪几种创建对象的方式





## 8、Set、Map和Array的异同、用法





## 9、谈谈宏任务和微任务





## 10、深拷贝，浅拷贝的区别是什么？利用递归手写深拷贝方法



## 11、apply()、call()、bind()之间的异同



## 12、数组的常用方法：改变原数组与不改变原数组各有哪些方法



## 13、写出下面一段程序的输出结果，并分析出原因

```javascript
new Promise(resolve => {
    console.log(1);
    setTimeout(() => console.log(2), 0);
    Promise.resolve.then(() => console.log(3))
    resolve();
}).then(() => console.log(4))
console.log(5)
```

