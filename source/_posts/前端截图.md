---
title: 前端截图
date: 2021-04-06 11:05:59
description: 使用html2canvas.js进行截图，使用canvg进行svg处理
tags: 前端 js canvas
---



## html2canvas前端截图功能

> 注意该插件无法处理svg, 需要提前处理好svg，把它转成canvas就可以了。

```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title></title>
</head>
<body>
<h1>标题１</h1>
<svg xmlns="http://www.w3.org/2000/svg" class="chart-container" width="900" height="440">
    <g transform="translate(90, 10)">
        <g transform="translate(0, 302)">
            <path fill="none" stroke="#777" d="M 0 6 V 0 H 779 V 6"/>
        </g>
        <g>
            <line stroke="#2e9ccc" stroke-width="50" transform="translate(253)" x1="0" y1="302" x2="0" y2="14"/>
            <line stroke="#2e9ccc" stroke-width="100" transform="translate(253)" x1="150" y1="302" x2="150" y2="119"/>
        </g>
    </g>
</svg>

<script src="https://cdn.bootcdn.net/ajax/libs/html2canvas/0.5.0-beta4/html2canvas.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/canvg/3.0.7/umd.js"></script>
<!--<script src="https://cdn.bootcdn.net/ajax/libs/html2canvas/0.5.0-beta4/html2canvas.svg.js"></script>-->
<script>
    // 由于html2canvas无法对svg截图，因此需要先把svg转成canvas。以下是对svg的处理
    var svgElem = document.querySelectorAll('svg');
    svgElem.forEach(function (node, index) {
        //获取svg的html代码
        var svg = node.outerHTML.trim();
        //创建一个<canvas>，用于放置转换后的元素
        var canvas = document.createElement('canvas');
        var ctx = canvas.getContext('2d');
        //将svg元素转换为canvas元素
        var v = canvg.Canvg.fromString(ctx, svg);
        v.start();
        node.parentNode.replaceChild(canvas, node);
    });

    html2canvas(document.body, {
        allowTaint: true,
        useCORS: true,
        x: 0,
        y: 0,
    }).then(function (canvas) {
        var base64Image = canvas.toDataURL('image/png');
        var image = document.createElement('img');
        image.src = base64Image;
        // debugger;
        image.onload = function () {
            document.body.appendChild(this);
        }
    });
</script>
</body>
</html>
```



使用html2canvas在前端生成图片遇到问题看下这个文章：

[使用html2canvas在前端生成图片](https://www.jianshu.com/p/22bd5b98e38a)





## 后台保存前端截取的图片

由于前端截取的图片只能在客户端预览和下载，如果需要得到这个图片的网络地址，需要上传图片到服务器保存。这里我使用django报错图片到静态资源目录来获得图片的网络地址。

```python
import uuid
import time
import base64

from django.core.files.storage import default_storage
from django.core.files.base import ContentFile

from account.conf import settings
from tastypie.resources import Resource
from tastypie.utils import trailing_slash


class PublicResource(Resource):
    """ 公共信息 """

    class Meta:
        resource_name = 'public'

    def prepend_urls(self):
        return [
            url(r"^(?P<resource_name>%s)/save-img%s$" % (
                self._meta.resource_name, trailing_slash()),
                self.wrap_view('save_img'), name="api_save_img"),
        ]
    
    def save_img(self, request, **kwargs):
        """
            说明：　截图保存，返回保存后的图片url
            接口：　api/v1/public/save-img
            方法: 　post
            参数：
            :param datas: 图片的base64字符串列表（必填）
            :return [{name: '', url: '', link: ''}]: 保存后的图片的名称和链接等
            """

        self.method_check(request, allowed=['post'])
        # self.init_lang(request)
        data = self.deserialize(request, request.body, format=request.META.get('CONTENT_TYPE', 'application/json'))

        img_list = data.get('datas', [])
        result = []

        for img in img_list:
            format, imgstr = img.split(';base64,')
            ext = format.split('/')[-1]

            # You can save this as file instance.

            # filename = '{}.{}'.format(uuid.uuid4().hex[:6], ext)
            # 毫秒级时间戳
            filename = '{}.{}'.format(int(round(time.time() * 1000)), ext)
            filepath = os.path.join(settings.MEDIA_ROOT, filename)
            fileurl = os.path.join(settings.MEDIA_URL, filename)
            data = ContentFile(base64.b64decode(imgstr), name=filename)
            default_storage.save(filepath, data)
            result.append({
                "name": filename,
                "url": fileurl,
                # "link": settings.HOMPAGE + fileurl
            })

            return self.create_response(request, result)

```

