---
title: 中国联通前端工程师笔试题
tags:
  - 笔试面试
abbrlink: 51a5d3af
date: 2021-04-10 17:12:10
---



## 前言

这里仅摘录一些感觉比较有意义，且有难度的题目。



## 正文

### 1、在大数据量场景下，以下哪种js中字符串连接方式较为高效（   ）

- a+=b

- a = a+b
- Array.join()
- Array.push()

> **+的处理机制是：**新建一个临时字符串，将新字符串赋值为a+b，然后返回这个临新字符串并同时销毁原始字符串，所以字符串连接效率较低。所以用Array.join()不会新建临时字符串效率更高。 （当然以上效率问题仅存在于低版本浏览器ie7-及以下，现在的新浏览器基本上都解决了这个问题，效率差不多）
>
>  
>
> 答案：C





### 2、下面代码输出结果是？

```javascript
var count = 0;
var Product = {
    count:1, 
    getCount: function(){
        return this.count++;
    }
}
console.log(Product.getCount())
var func = Product.getCount
console.log(func())
```

- 1    1
- 2    2
- 1    2
- 1    0

> 这里其实也很简单，但是比较容易粗心做错，也记录下吧！
>
> this即指向函数调用的对象，第一个调用对象是Product，Product.count就是1。第二个调用对象是Window，Window.count就是0；
>
> 另外的两个知识点就是 a++是先返回，后加。var定义的是全局变量。
>
> 
>
> 答案：D



### 3、({} + 'b' > {} + 'a')的返回值是（   ）

- a
- b
- true
- false



> 这题我一开始想简单了，下面是我错误的推算过程：
>
> ```javascript
> var obj = {};
> obj.valueOf().toString() === '[object Object]'
> 
> // 所以，{} + 'b' > {} + 'a' 为 true
> ```
>
> 发现大错特错了。所以这题的我只知道答案，但是不知道为什么？求解！
>
> 下面是我的一些推理过程：
>
> https://www.jb51.net/article/46753.htm
>
> ```javascript
> {} + 'b' > {} + 'a'
> false
> ({} + 'b' > {} + 'a')
> true
> ({} + 'b') > ({} + 'a')
> true
> 
> 'a' + {}
> "a[object Object]"
> {} + 'a'
> NaN
> 'a' + [1,2,3]
> "a1,2,3"
> [1,2,3] + 'a'
> "1,2,3a"
> 
> NaN - NaN
> NaN
> NaN + NaN
> NaN
> NaN > NaN
> false
> NaN < NaN
> false
> NaN === NaN
> false
> NaN == NaN
> false
> ```
>
> 
>
> 答案：C



### 4、let obj= {x: 1}; 对obj实现浅拷贝

这题谈到了对象的浅拷贝，这里扩展下，如何实现对象和数组的深浅拷贝。

大佬的细致分析见：https://segmentfault.com/a/1190000020255831

```javascript
// 浅拷贝方法一：Object.assign/Array.slice
Object.assign({}, obj)
arr.slice();

// 浅拷贝方法二：解构赋值
{...obj}
[...arr]

// 深拷贝方法一：JSON.parse和JSON.stringify
// 注意有比较严重的弊端就是值为undefined和function的数据没有拷贝过来。这里另外扩展一下，ajax发送json数据的时候其实也调用了该方法，数据中的undefined和function你看看是不是没掉了
JSON.parse(JSON.stringify(obj))

// 深拷贝方法二：递归
// 这里考虑只存在对象和数组，如果要考虑更细致，请看：https://segmentfault.com/a/1190000020255831
function extend(data) {
    if (typeof data === 'object' && data) {
        let val = typeof data.length === 'number' ? [] : {}
        for(let i in data) {
            val[i] = extend(data[i])
        }
        return val
    } else {
        return data
    }
}
extend(obj)
extend(arr)
```



### 5、JavaScript改变this指向有哪些方式？

大佬更细致的分析请见：[https://mp.weixin.qq.com/s/DlUJq0JJzHjnPwCI_SAI5Q](面试官想知道你有多理解call,apply,bind？)

```
fun.call(thisArg, param1, param2, ...)
fun.apply(thisArg, [param1,param2,...])
fun.bind(thisArg, param1, param2, ...)
```

**作用：**改变函数执行时的this指向，目前所有关于它们的运用，都是基于这一点来进行的。

**call、apply和bind是挂在Function对象上的三个方法,只有函数才有这些方法。**

> 只要是函数就可以，比如: Object.prototype.toString就是个函数，我们经常看到这样的用法：Object.prototype.toString.call(data)



**call/apply与bind的区别：**

**参数：**

- apply是第2个参数，这个参数是一个数组：传给fun参数都写在数组中。
- call和bind从第2~n的参数都是传给fun的。

**执行：**

- call/apply改变了函数的this上下文后马上执行该函数
- bind则是返回改变了上下文后的函数,不执行该函数

**返回值:**

- call/apply 返回fun的执行结果
- bind返回fun的拷贝，并指定了fun的this指向，保存了fun的参数。



### 6、html5手机端适配，怎么实现1rem表示为50px?

`rem`是相对于根元素`<html>`，这样就意味着，我们只需要在根元素确定一个参考值，这个参考值设置为多少，完全可以根据您自己的需求来定。 我们知道，浏览器默认的字号`16px`，来看一些`px`单位与`rem`之间的转换关系：

```
|  px  |     rem       |
------------------------
|  12  | 12/16 = .75   |
|  14  | 14/16 = .875  |
|  16  | 16/16 = 1     |
|  18  | 18/16 = 1.125 |
|  20  | 20/16 = 1.25  |
|  24  | 24/16 = 1.5   |
|  30  | 30/16 = 1.875 |
|  36  | 36/16 = 2.25  |
|  42  | 42/16 = 2.625 |
|  48  | 48/16 = 3     |
|  50  | 50/16 = 3.125     |
-------------------------    
```

那么，要实现1rem == 50px，只需要设置html的大小为50px即可，即`html { font-size:50px; }`。

值得注意的是，`em`是相对于父级元素的字体大小，`rem`是相对于根元素html的字体大小，`px`是相对于显示器屏幕分辨率的。

em和rem也可以不仅仅给字体使用，凡是用px的地方也可以用em和rem。

### 7、如何准确判断一个变量是数组类型?

```javascript
function isType(data, type) {

    const typeObj = {

        '[object String]': 'string',

        '[object Number]': 'number',

        '[object Boolean]': 'boolean',

        '[object Null]': 'null',

        '[object Undefined]': 'undefined',

        '[object Object]': 'object',

        '[object Array]': 'array',

        '[object Function]': 'function',

        '[object Date]': 'date', // Object.prototype.toString.call(new Date())

        '[object RegExp]': 'regExp',

        '[object Map]': 'map',

        '[object Set]': 'set',

        '[object HTMLDivElement]': 'dom', // document.querySelector('#app')

        '[object WeakMap]': 'weakMap',

        '[object Window]': 'window', // Object.prototype.toString.call(window)

        '[object Error]': 'error', // new Error('1')

        '[object Arguments]': 'arguments',

    }

    let name = Object.prototype.toString.call(data) // 借用Object.prototype.toString()获取数据类型

    let typeName = typeObj[name] || '未知类型' // 匹配数据类型

    return typeName === type // 判断该数据类型是否为传入的类型

}

console.log(
    
    isType([], 'array'), // true

    isType({}, 'object'), // true

    isType(new Date(), 'object'), // false

    isType(new Date(), 'date'), // true

)
```





### 8、请描述一下cookie，sessionStorage和localStorage有什么区别?

https://blog.csdn.net/weixin_42614080/article/details/90706499





### 9、简述浏览器发起一个网络请求（HTTP请求事务）后都经历了哪些步骤?

这题感觉比较摸不着头脑，写一下我认为的答案好了。

```
域名解析：浏览器按照顺序解析，自身的dns缓存——客户端自身的dns缓存——本地host文件——路由器缓存
建立连接：浏览器获得域名对应的ip地址后，发起tcp三次握手，将客户端与服务端建立连接（http基于tcp协议，tcp为传输层协议）
返回数据：服务端接收请求并将数据返回给浏览器
处理数据：浏览器拿到返回资源后进行客户端渲染，将完整页面呈现给用户。
```

这是网上看到的一些相关文章：

[从输入url到页面展示详解](https://mp.weixin.qq.com/s/WYCeJivkRPpiZLEdstyfAg)

[面试环节：在浏览器输入 URL 回车之后发生了什么？（超详细版）](https://zhuanlan.zhihu.com/p/82956784)



### 10、写一个原型链继承的例子

```javascript
// 父类

function supFather(name) {

    this.name = name;

    this.colors = ['red', 'blue', 'green']; // 复杂类型

}

supFather.prototype.sayName = function (age) {

    console.log(this.name, 'age');

};

// 子类

function sub(name, age) {

    // 借用父类的方法：修改它的this指向,赋值父类的构造函数里面方法、属性到子类上

    supFather.call(this, name);

    this.age = age;

}

// 重写子类的prototype，修正constructor指向

function inheritPrototype(sonFn, fatherFn) {

    sonFn.prototype = Object.create(fatherFn.prototype); // 继承父类的属性以及方法

    sonFn.prototype.constructor = sonFn; // 修正constructor指向到继承的那个函数上

}

inheritPrototype(sub, supFather);

sub.prototype.sayAge = function () {

    console.log(this.age, 'foo');

};

// 实例化子类，可以在实例上找到属性、方法

const instance1 = new sub("OBKoro1", 24);

const instance2 = new sub("小明", 18);

instance1.colors.push('black')

console.log(instance1) // {"name":"OBKoro1","colors":["red","blue","green","black"],"age":24}

console.log(instance2) // {"name":"小明","colors":["red","blue","green"],"age":18}
```





## 11、下面代码的执行结果是？

```javascript
for(var i = 0; i < 3; ++i){
    setTimeout(function(){console.log(i)}, 0)
}
```



> 这题考察的是js的异步任务队列，js会先执行主队列，然后再执行异步任务队列（异步任务队列又分为宏任务和微任务）。所以本题答案是3
>
> 
>
> 这里主要拓展一下，如果需要输出0， 1， 2该怎么办呢？
>
> 答案是用ES6的let，因为let是块级别作用域
>
> ```javascript
> for(let i = 0; i < 3; ++i){
>     setTimeout(function(){console.log(i)}, 0)
> }
> ```