---
title: 容器
description: 暂无描述！
tags:
  - 学习中
  - Docker
abbrlink: 8f8103b7
date: 2021-01-20 00:15:23
---



## 获取镜像

如果我们本地没有 `ubuntu` 镜像，我们可以使用 docker pull 命令来载入 `ubuntu` 镜像：

```
$ docker pull ubuntu
```

### 启动容器

以下命令使用 `ubuntu` 镜像启动一个容器，参数为以命令行模式进入该容器：

```
$ docker run -it ubuntu /bin/bash
```

> 参数说明：
>
> **-i**: 交互式操作
>
> **-t**: 终端
>
> **ubuntu**: ubuntu 镜像
>
> **/bin/bash**：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 /bin/bash



docker中有这样几个概念：

- dockerfile
- image
- container

实际上你可以简单的把**image理解为可执行程序，container就是运行起来的进程**。

那么写程序需要源代码，那么“写”image就需要dockerfile，dockerfile就是image的源代码，docker就是"编译器"。

因此我们只需要在dockerfile中指定需要哪些程序、依赖什么样的配置，之后把dockerfile交给“编译器”docker进行“编译”，也就是docker build命令，生成的可执行程序就是image，之后就可以运行这个image了，这就是docker run命令，image运行起来后就是docker container。





**docker的底层实现**



docker基于Linux内核提供这样几项功能实现的：

- **NameSpace**

  我们知道Linux中的PID、IPC、网络等资源是全局的，而NameSpace机制是一种资源隔离方案，在该机制下这些资源就不再是全局的了，而是属于某个特定的NameSpace，各个NameSpace下的资源互不干扰，这就使得每个NameSpace看上去就像一个独立的操作系统一样，但是只有NameSpace是不够。

- **Control groups**

  虽然有了NameSpace技术可以实现资源隔离，但进程还是可以不受控的访问系统资源，比如CPU、内存、磁盘、网络等，为了控制容器中进程对资源的访问，Docker采用control groups技术(也就是cgroup)，有了cgroup就可以控制容器中进程对系统资源的消耗了，比如你可以限制某个容器使用内存的上限、可以在哪些CPU上运行等等。

有了这两项技术，容器看起来就真的像是独立的操作系统了。